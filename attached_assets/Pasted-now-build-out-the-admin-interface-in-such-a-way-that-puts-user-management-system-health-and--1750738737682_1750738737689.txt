now build out the admin interface in such a way 
  that puts user management, system health and 
  other crucial parameters in my view on the 
  frontend

● I'll build a comprehensive admin interface that
  gives you complete visibility into user
  management, system health, and all crucial
  parameters. Let me create a full admin dashboard
   system.

● Update Todos
  ⎿ ☐ Create main admin dashboard with overview   
      metrics
    ☐ Build user management interface with search
      and filtering
    ☐ Create system health monitoring dashboard
    ☐ Add security events and audit log viewer
    ☐ Build subscription and usage analytics
    ☐ Create admin settings and configuration
      panel
    ☐ Add real-time metrics and alerts

● Update Todos
  ⎿ ☐ Create main admin dashboard with overview   
      metrics
    ☐ Build user management interface with search
      and filtering
    ☐ Create system health monitoring dashboard
    ☐ Add security events and audit log viewer
    ☐ Build subscription and usage analytics
    ☐ Create admin settings and configuration
      panel
    ☐ Add real-time metrics and alerts

● First, let me create the main admin dashboard
  API endpoints to provide the data:

● Write(server/admin-routes.ts)
  ⎿  Wrote 377 lines to server/admin-routes.ts    
     import { Express, Request, Response } from
     "express";
     import { requireAdminAuth } from "./auth";
     import { databaseStorage } from "./storage";
     import { securityLogger } from
     "./security-logger";
     import { emailRecoveryService } from
     "./email-recovery-service";
     import { priorityQueue } from
     "./priority-queue";
     import { z } from "zod";
     export function registerAdminRoutes(app: 
     Express) {
     … +367 lines (ctrl+r to expand)

● Now I need to add the missing database methods
  that the admin routes need:

● Update(server/database-storage.ts)
  ⎿  Updated server/database-storage.ts with 251  
     additions
       484          .returning();
       485        return results.length;
       486      }
       487 +  
       488 +    // Admin Dashboard Methods
       489 +    async getTotalUserCount(): 
     Promise<
           + number> {
       490 +      const result = await db
       491 +        .select({ count: sql`count(*)` 
           + })
       492 +        .from(users);
       493 +      return parseInt(result[0].count 
     a
           + s string);
       494 +    }
       495 +  
       496 +    async 
     getActiveSubscriptionCount():
           +  Promise<number> {
       497 +      const result = await db
       498 +        .select({ count: sql`count(*)` 
           + })
       499 +        .from(userSubscriptions)
       500 +        
     .where(eq(userSubscriptions.sta
           + tus, 'active'));
       501 +      return parseInt(result[0].count 
     a
           + s string);
       502 +    }
       503 +  
       504 +    async getUserCountSince(date: 
     Date)
           + : Promise<number> {
       505 +      const result = await db
       506 +        .select({ count: sql`count(*)` 
           + })
       507 +        .from(users)
       508 +        .where(sql`${users.createdAt} 
     >
           + = ${date}`);
       509 +      return parseInt(result[0].count 
     a
           + s string);
       510 +    }
       511 +  
       512 +    async 
     getSubscriptionCountSince(dat
           + e: Date): Promise<number> {
       513 +      const result = await db
       514 +        .select({ count: sql`count(*)` 
           + })
       515 +        .from(userSubscriptions)
       516 +        .where(and(
       517 +          eq(userSubscriptions.status, 
           + 'active'),
       518 +          
     sql`${userSubscriptions.creat
           + edAt} >= ${date}`
       519 +        ));
       520 +      return parseInt(result[0].count 
     a
           + s string);
       521 +    }
       522 +  
       523 +    async 
     getDocumentAnalysisCountSince
           + (date: Date): Promise<number> {
       524 +      // Since documents are 
     session-ba
           + sed, we'll estimate from usage 
     records
       525 +      const result = await db
       526 +        .select({ total: 
     sql`sum(${usag
           + eRecords.documentsAnalyzed})` })
       527 +        .from(usageRecords)
       528 +        
     .where(sql`${usageRecords.creat
           + edAt} >= ${date}`);
       529 +      return parseInt(result[0].total 
     a
           + s string) || 0;
       530 +    }
       531 +  
       532 +    async getUsers(options: {
       533 +      page: number;
       534 +      limit: number;
       535 +      search?: string;
       536 +      sortBy: string;
       537 +      sortOrder: string;
       538 +      hasSubscription?: boolean;
       539 +    }): Promise<{
       540 +      users: User[];
       541 +      total: number;
       542 +      page: number;
       543 +      limit: number;
       544 +      totalPages: number;
       545 +    }> {
       546 +      const offset = (options.page - 
     1)
           +  * options.limit;
       547 +      
       548 +      // Build query conditions
       549 +      let conditions = sql`1=1`;
       550 +      
       551 +      if (options.search) {
       552 +        const searchTerm = 
     `%${options.
           + search}%`;
       553 +        conditions = 
     sql`(${users.email
           + } ILIKE ${searchTerm} OR 
     ${users.usern
           + ame} ILIKE ${searchTerm})`;
       554 +      }
       555 +  
       556 +      if (options.hasSubscription !== 
     u
           + ndefined) {
       557 +        if (options.hasSubscription) {
       558 +          conditions = 
     sql`${conditions
           + } AND EXISTS (
       559 +            SELECT 1 FROM 
     ${userSubscri
           + ptions} 
       560 +            WHERE 
     ${userSubscriptions.u
           + serId} = ${users.id} 
       561 +            AND 
     ${userSubscriptions.sta
           + tus} = 'active'
       562 +          )`;
       563 +        } else {
       564 +          conditions = 
     sql`${conditions
           + } AND NOT EXISTS (
       565 +            SELECT 1 FROM 
     ${userSubscri
           + ptions} 
       566 +            WHERE 
     ${userSubscriptions.u
           + serId} = ${users.id} 
       567 +            AND 
     ${userSubscriptions.sta
           + tus} = 'active'
       568 +          )`;
       569 +        }
       570 +      }
       571 +  
       572 +      // Get total count
       573 +      const totalResult = await db
       574 +        .select({ count: sql`count(*)` 
           + })
       575 +        .from(users)
       576 +        .where(conditions);
       577 +      const total = 
     parseInt(totalResul
           + t[0].count as string);
       578 +  
       579 +      // Get users with sorting
       580 +      const orderColumn = 
     options.sortB
           + y === 'email' ? users.email : 
     users.cr
           + eatedAt;
       581 +      const orderDirection = 
     options.so
           + rtOrder === 'asc' ? sql`ASC` : 
     sql`DES
           + C`;
       582 +      
       583 +      const userResults = await db
       584 +        .select()
       585 +        .from(users)
       586 +        .where(conditions)
       587 +        .orderBy(sql`${orderColumn} 
     ${o
           + rderDirection}`)
       588 +        .limit(options.limit)
       589 +        .offset(offset);
       590 +  
       591 +      return {
       592 +        users: userResults.map(user => 
           + ({ ...user, hashedPassword: undefined 
           + } as any)),
       593 +        total,
       594 +        page: options.page,
       595 +        limit: options.limit,
       596 +        totalPages: Math.ceil(total / 
     o
           + ptions.limit)
       597 +      };
       598 +    }
       599 +  
       600 +    async getSubscriptionTiers(): 
     Promi
           + se<any[]> {
       601 +      // This would typically come 
     from
           +  a tiers table, but for now return 
     sta
           + tic data
       602 +      return [
       603 +        { id: 'free', name: 'Free', 
     pri
           + ce: 0 },
       604 +        { id: 'basic', name: 'Basic', 
     p
           + rice: 9.99 },
       605 +        { id: 'premium', name: 
     'Premium
           + ', price: 19.99 },
       606 +        { id: 'enterprise', name: 
     'Ente
           + rprise', price: 49.99 }
       607 +      ];
       608 +    }
       609 +  
       610 +    async getUserGrowthData(startDate: 
           + Date): Promise<any[]> {
       611 +      const result = await db
       612 +        .select({
       613 +          date: 
     sql`DATE(${users.create
           + dAt})`,
       614 +          count: sql`count(*)`
       615 +        })
       616 +        .from(users)
       617 +        .where(sql`${users.createdAt} 
     >
           + = ${startDate}`)
       618 +        
     .groupBy(sql`DATE(${users.creat
           + edAt})`)
       619 +        
     .orderBy(sql`DATE(${users.creat
           + edAt})`);
       620 +      
       621 +      return result;
       622 +    }
       623 +  
       624 +    async 
     getSubscriptionAnalytics(star
           + tDate: Date): Promise<{
       625 +      byTier: any[];
       626 +      growth: any[];
       627 +      churn: any[];
       628 +    }> {
       629 +      // Subscriptions by tier
       630 +      const byTier = await db
       631 +        .select({
       632 +          tier: 
     userSubscriptions.tierI
           + d,
       633 +          count: sql`count(*)`
       634 +        })
       635 +        .from(userSubscriptions)
       636 +        
     .where(eq(userSubscriptions.sta
           + tus, 'active'))
       637 +        
     .groupBy(userSubscriptions.tier
           + Id);
       638 +  
       639 +      // Subscription growth
       640 +      const growth = await db
       641 +        .select({
       642 +          date: 
     sql`DATE(${userSubscrip
           + tions.createdAt})`,
       643 +          count: sql`count(*)`
       644 +        })
       645 +        .from(userSubscriptions)
       646 +        .where(and(
       647 +          eq(userSubscriptions.status, 
           + 'active'),
       648 +          
     sql`${userSubscriptions.creat
           + edAt} >= ${startDate}`
       649 +        ))
       650 +        
     .groupBy(sql`DATE(${userSubscri
           + ptions.createdAt})`)
       651 +        
     .orderBy(sql`DATE(${userSubscri
           + ptions.createdAt})`);
       652 +  
       653 +      return {
       654 +        byTier,
       655 +        growth,
       656 +        churn: [] // Would need 
     additio
           + nal tracking for churn analysis
       657 +      };
       658 +    }
       659 +  
       660 +    async getUsageAnalytics(startDate: 
           + Date): Promise<{
       661 +      totalDocuments: number;
       662 +      totalTokens: number;
       663 +      avgDocumentsPerUser: number;
       664 +      byTier: any[];
       665 +    }> {
       666 +      const totalResult = await db
       667 +        .select({
       668 +          totalDocuments: 
     sql`sum(${usa
           + geRecords.documentsAnalyzed})`,
       669 +          totalTokens: 
     sql`sum(${usageR
           + ecords.tokensUsed})`
       670 +        })
       671 +        .from(usageRecords)
       672 +        
     .where(sql`${usageRecords.creat
           + edAt} >= ${startDate}`);
       673 +  
       674 +      const userCountResult = await db
       675 +        .select({ count: 
     sql`count(DIST
           + INCT ${usageRecords.userId})` })
       676 +        .from(usageRecords)
       677 +        
     .where(sql`${usageRecords.creat
           + edAt} >= ${startDate}`);
       678 +  
       679 +      const totalDocuments = 
     parseInt(t
           + otalResult[0]?.totalDocuments as 
     strin
           + g) || 0;
       680 +      const totalTokens = 
     parseInt(tota
           + lResult[0]?.totalTokens as string) || 
           + 0;
       681 +      const userCount = 
     parseInt(userCo
           + untResult[0]?.count as string) || 1;
       682 +  
       683 +      const byTierResult = await db
       684 +        .select({
       685 +          tier: 
     sql`COALESCE(${userSubs
           + criptions.tierId}, 'free')`,
       686 +          documents: 
     sql`sum(${usageRec
           + ords.documentsAnalyzed})`,
       687 +          tokens: 
     sql`sum(${usageRecord
           + s.tokensUsed})`
       688 +        })
       689 +        .from(usageRecords)
       690 +        .leftJoin(userSubscriptions, 
     eq
           + (usageRecords.subscriptionId, 
     userSubs
           + criptions.id))
       691 +        
     .where(sql`${usageRecords.creat
           + edAt} >= ${startDate}`)
       692 +        
     .groupBy(sql`COALESCE(${userSub
           + scriptions.tierId}, 'free')`);
       693 +  
       694 +      return {
       695 +        totalDocuments,
       696 +        totalTokens,
       697 +        avgDocumentsPerUser: 
     Math.round
           + (totalDocuments / userCount),
       698 +        byTier: byTierResult
       699 +      };
       700 +    }
       701 +  
       702 +    async 
     getRevenueAnalytics(startDate
           + : Date): Promise<{
       703 +      totalRevenue: number;
       704 +      byTier: any[];
       705 +      growth: any[];
       706 +    }> {
       707 +      // This would need payment 
     record
           + s table for accurate revenue tracking
       708 +      // For now, estimate based on 
     act
           + ive subscriptions and tier prices
       709 +      const tierPrices: Record<string, 
           + number> = {
       710 +        'free': 0,
       711 +        'basic': 9.99,
       712 +        'premium': 19.99,
       713 +        'enterprise': 49.99
       714 +      };
       715 +  
       716 +      const byTier = await db
       717 +        .select({
       718 +          tier: 
     userSubscriptions.tierI
           + d,
       719 +          count: sql`count(*)`
       720 +        })
       721 +        .from(userSubscriptions)
       722 +        
     .where(eq(userSubscriptions.sta
           + tus, 'active'))
       723 +        
     .groupBy(userSubscriptions.tier
           + Id);
       724 +  
       725 +      const estimatedRevenue = 
     byTier.r
           + educe((total, tier) => {
       726 +        return total + 
     (tierPrices[tier
           + .tier] || 0) * parseInt(tier.count as 
           + string);
       727 +      }, 0);
       728 +  
       729 +      return {
       730 +        totalRevenue: 
     estimatedRevenue,
       731 +        byTier: byTier.map(tier => ({
       732 +          ...tier,
       733 +          revenue: 
     (tierPrices[tier.tie
           + r] || 0) * parseInt(tier.count as 
     stri
           + ng)
       734 +        })),
       735 +        growth: [] // Would need 
     histor
           + ical revenue data
       736 +      };
       737 +    }
       738    }
       739   \ No newline at end of file
  ⎿  Claude usage limit reached. Your limit will 
     reset at 6am (UTC).
